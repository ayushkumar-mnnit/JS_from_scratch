

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chai aur code | DOM</title>
</head>
<body style="background-color: #212121; color: #fff;">
    <ul class="language">
        <li>Javascript</li>
    </ul>

    <button id="ad">add</button>
    <button id="ed">edit</button>
    <button id="de">delete</button>
</body>
<script>

// add

    function addLanguage(langName){
        const li = document.createElement('li');
        li.innerHTML = `${langName}`
        document.querySelector('.language').appendChild(li)
    }
  

    document.querySelector('#ad').addEventListener('click', () => {
        addLanguage("python")
        addLanguage("typescript")
    })


    //Edit
    const secondLang = document.querySelector("li:nth-child(1)")
    console.log(secondLang);
    const newli = document.createElement('li')
   
    
    document.querySelector('#ed').addEventListener('click', () => {
         newli.textContent = "C++"
        secondLang.replaceWith(newli)  
    })

    //edit: another way using outerHTML
    // const firstLang = document.querySelector("li:first-child")
    // firstLang.outerHTML = '<li>TypeScript</li>'

    //remove
    const lastLang = document.querySelector('li:first-child')

    document.querySelector('#de').addEventListener('click', () => {
        lastLang.remove()
    })



</script>
</html>

<!-- 
also note one thing related to  optimization: always prefer storing the element fetched from DOM in a variable.so that everytime we need to access any of its child then we dont need to tarverse entire tree from very root. -->






<!--  This part is kind of intro to what happens under the hood of react and how is it realted to DOM.

when we work with React or any other library/framwork we actually dont need to use DOM explicitely we simply write JSX (which is js in simple html like syntax which eventually got added to empty script of index.html and updates the UI) code in react and under the hood react manages all this so we dont even realise the usefullness of DOM, but if we have to work in pure html,css,js then we use DOM and understand its power.

what happens in React ?

in react we have a very simple html doc which is empty, nothing in body but there is an empty script tag with id ='root'.
now what happens is when we load the application then empty DOM is created on browser with no element nodes.This is called real DOM
but we write code in componets which is then wrapped in a App.jsx component and its pulled in a main JS file called index.js.

now when we write " createRoot(document.getElementById('root')).render(<App />) " then it selects the element with id='root' and 
injects all the code in that script tag of html file and "createRoot()" particularly creates a DOM of its own (diff from real dom) and is known as "virtual DOM".

[ its nothing new , its like currently we were writing JS within script tag of html itslef but now we wrote JS somewhere else in a file and imported it like external JS. ]

Real dom is always painted on browser freshly, means if any change occurs then DOM is tree is re-created and that causes loading of page which is often seen in traditional websites.
But now it in react it works on "Reconciliation algorithm"-The algorithm React uses to diff one tree with another to determine which parts need to be changed.So basically here entrire DOM of client side is not re-created but diffing algorithm (reconciliation algorithm) runs on virtual dom and compares changes in real dom with virtual dom, then updates only those changes in real dom.

That's why react applications are fast and efficient.

But still performance can be optimized because there is a scope of improvement, see how ??

1. In a UI, it's not necessary for every update to be applied immediately; in fact, doing so can be wasteful, causing frames to drop and degrading the user experience because we know whenever any change in state or prop is made, it will trigger a re-render of the component
causing an update to be made if some state changed , immediately 2-3 times then every time updating the UI makes no sense, it would be better to propagate the latest change right.

2. Different types of updates have different priorities â€” an animation update needs to complete more quickly than, say, an update from a data store. (just like promises have higher priority in JS)

3. A push-based approach requires the app (you, the programmer) to decide how to schedule work. A pull-based approach allows the framework (React) to be smart and make those decisions for you. (ex.changes due to state change are pull based , means react decides we can't forcefully push the updates if state changes)


so to tackle these problems, "React fibre" was introduced becoz React doesn't currently take advantage of scheduling in a significant way; an update results in the entire subtree being re-rendered immediately.Primary goal of Fiber was to enable React to take advantage of scheduling. Specifically, we need to be able to

1. pause work and come back to it later.
2. assign priority to different types of work.
3. reuse previously completed work.
4. abort work if it's no longer needed.


Architecture wise ,

Wouldn't it be great if we could customize the behavior of the call stack to optimize for rendering UIs? Wouldn't it be great if we could interrupt the call stack at will and manipulate stack frames manually?
That's the purpose of React Fiber. Fiber is reimplementation of the stack, specialized for React components.
stucture wise, fiber is a JavaScript object that contains information about a component, its input, and its output.


What's the main algorithm behind React Fiber, how its differenet from reconciliation?

" 1. Different component types are assumed to generate substantially different trees. React will not attempt to diff them, but rather replace the old tree completely.
2. Diffing of lists is performed using keys. Keys should be "stable, predictable, and unique."


B.t.w fibre is not new to react , it has been there for a long time ~ 7yrs. conventional reconciliation algo is not used since then.


Also keep in mind component in react renders whenever states or props changes and if parent renders then its all children re-renders but if child re-renders then only that child will re-render.Ex- in a component there are 3 functions and parent is catching some prop then if prop changes then all functions will re-render but if a particular function re-renders say due to change in dependency array var of useEffect then only that function will re-render.


And i guess that's enough to know about behind the scenes of react library.

-->